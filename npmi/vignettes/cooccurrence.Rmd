---
title: "Calculate cooccurrenc metrics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cooccurrence}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup}
library(tidyverse)
library(npmi)

# Load example data
threads <- read_csv2(system.file("extdata", "threads.csv", package = "npmi"))
threads <- select(threads,item=id,feature,weight)
threads

```

```{r}

# Count cooccurrence of features
threads %>%
  count_pairs() %>% 
  pivot_wider(names_from=feature2,values_from=n)

```

```{r}

# Calculate p values for each combination
threads %>% 
  get_cooccurrence(npmi = T) %>% 
  as_tibble()

```

```{r}
# Resamle cooccurrence and calculate NPMI
# Be patient...simulates 1000 random worlds for the baseline probability
pairs <- threads %>%
  resample_cooccurrence(trials=100)

pairs %>% 
  filter(metric=="p_cond_source") %>% 
  select(feature_source, feature_target, value, value_mean, boot_ratio, boot_npmi,sig)
```


```{r}

# Plot count matrix
threads %>% 
  get_cooccurrence(metrics = T) %>% 
  as_tibble() %>% 
  select(source=feature_source,target=feature_target,value=p_cond_source) %>% 
  matrixmap() +
  theme_bw(base_size=20)

```

```{r}


#Plot npmi matrix
pairs %>% 
  filter(metric=="p_cond_source") %>% 
  filter(sig == T) %>% 
  select(source=feature_source,target=feature_target,value=boot_npmi) %>% 
  matrixmap() +
  theme_bw(base_size=20)

```

